// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subscription_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SubscriptionState {
  bool get hasPlus => throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  bool get isRestoring => throw _privateConstructorUsedError;
  bool get isShowingPaywall => throw _privateConstructorUsedError;
  String? get error => throw _privateConstructorUsedError;
  DateTime? get lastChecked => throw _privateConstructorUsedError;
  Map<String, bool>? get entitlements => throw _privateConstructorUsedError;
  Map<String, dynamic>? get subscriptionMetadata =>
      throw _privateConstructorUsedError;

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubscriptionStateCopyWith<SubscriptionState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionStateCopyWith<$Res> {
  factory $SubscriptionStateCopyWith(
          SubscriptionState value, $Res Function(SubscriptionState) then) =
      _$SubscriptionStateCopyWithImpl<$Res, SubscriptionState>;
  @useResult
  $Res call(
      {bool hasPlus,
      bool isLoading,
      bool isRestoring,
      bool isShowingPaywall,
      String? error,
      DateTime? lastChecked,
      Map<String, bool>? entitlements,
      Map<String, dynamic>? subscriptionMetadata});
}

/// @nodoc
class _$SubscriptionStateCopyWithImpl<$Res, $Val extends SubscriptionState>
    implements $SubscriptionStateCopyWith<$Res> {
  _$SubscriptionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hasPlus = null,
    Object? isLoading = null,
    Object? isRestoring = null,
    Object? isShowingPaywall = null,
    Object? error = freezed,
    Object? lastChecked = freezed,
    Object? entitlements = freezed,
    Object? subscriptionMetadata = freezed,
  }) {
    return _then(_value.copyWith(
      hasPlus: null == hasPlus
          ? _value.hasPlus
          : hasPlus // ignore: cast_nullable_to_non_nullable
              as bool,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isRestoring: null == isRestoring
          ? _value.isRestoring
          : isRestoring // ignore: cast_nullable_to_non_nullable
              as bool,
      isShowingPaywall: null == isShowingPaywall
          ? _value.isShowingPaywall
          : isShowingPaywall // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      lastChecked: freezed == lastChecked
          ? _value.lastChecked
          : lastChecked // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      entitlements: freezed == entitlements
          ? _value.entitlements
          : entitlements // ignore: cast_nullable_to_non_nullable
              as Map<String, bool>?,
      subscriptionMetadata: freezed == subscriptionMetadata
          ? _value.subscriptionMetadata
          : subscriptionMetadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubscriptionStateImplCopyWith<$Res>
    implements $SubscriptionStateCopyWith<$Res> {
  factory _$$SubscriptionStateImplCopyWith(_$SubscriptionStateImpl value,
          $Res Function(_$SubscriptionStateImpl) then) =
      __$$SubscriptionStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool hasPlus,
      bool isLoading,
      bool isRestoring,
      bool isShowingPaywall,
      String? error,
      DateTime? lastChecked,
      Map<String, bool>? entitlements,
      Map<String, dynamic>? subscriptionMetadata});
}

/// @nodoc
class __$$SubscriptionStateImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$SubscriptionStateImpl>
    implements _$$SubscriptionStateImplCopyWith<$Res> {
  __$$SubscriptionStateImplCopyWithImpl(_$SubscriptionStateImpl _value,
      $Res Function(_$SubscriptionStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hasPlus = null,
    Object? isLoading = null,
    Object? isRestoring = null,
    Object? isShowingPaywall = null,
    Object? error = freezed,
    Object? lastChecked = freezed,
    Object? entitlements = freezed,
    Object? subscriptionMetadata = freezed,
  }) {
    return _then(_$SubscriptionStateImpl(
      hasPlus: null == hasPlus
          ? _value.hasPlus
          : hasPlus // ignore: cast_nullable_to_non_nullable
              as bool,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      isRestoring: null == isRestoring
          ? _value.isRestoring
          : isRestoring // ignore: cast_nullable_to_non_nullable
              as bool,
      isShowingPaywall: null == isShowingPaywall
          ? _value.isShowingPaywall
          : isShowingPaywall // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      lastChecked: freezed == lastChecked
          ? _value.lastChecked
          : lastChecked // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      entitlements: freezed == entitlements
          ? _value._entitlements
          : entitlements // ignore: cast_nullable_to_non_nullable
              as Map<String, bool>?,
      subscriptionMetadata: freezed == subscriptionMetadata
          ? _value._subscriptionMetadata
          : subscriptionMetadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc

class _$SubscriptionStateImpl extends _SubscriptionState {
  const _$SubscriptionStateImpl(
      {this.hasPlus = false,
      this.isLoading = false,
      this.isRestoring = false,
      this.isShowingPaywall = false,
      this.error,
      this.lastChecked,
      final Map<String, bool>? entitlements,
      final Map<String, dynamic>? subscriptionMetadata})
      : _entitlements = entitlements,
        _subscriptionMetadata = subscriptionMetadata,
        super._();

  @override
  @JsonKey()
  final bool hasPlus;
  @override
  @JsonKey()
  final bool isLoading;
  @override
  @JsonKey()
  final bool isRestoring;
  @override
  @JsonKey()
  final bool isShowingPaywall;
  @override
  final String? error;
  @override
  final DateTime? lastChecked;
  final Map<String, bool>? _entitlements;
  @override
  Map<String, bool>? get entitlements {
    final value = _entitlements;
    if (value == null) return null;
    if (_entitlements is EqualUnmodifiableMapView) return _entitlements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _subscriptionMetadata;
  @override
  Map<String, dynamic>? get subscriptionMetadata {
    final value = _subscriptionMetadata;
    if (value == null) return null;
    if (_subscriptionMetadata is EqualUnmodifiableMapView)
      return _subscriptionMetadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'SubscriptionState(hasPlus: $hasPlus, isLoading: $isLoading, isRestoring: $isRestoring, isShowingPaywall: $isShowingPaywall, error: $error, lastChecked: $lastChecked, entitlements: $entitlements, subscriptionMetadata: $subscriptionMetadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionStateImpl &&
            (identical(other.hasPlus, hasPlus) || other.hasPlus == hasPlus) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.isRestoring, isRestoring) ||
                other.isRestoring == isRestoring) &&
            (identical(other.isShowingPaywall, isShowingPaywall) ||
                other.isShowingPaywall == isShowingPaywall) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.lastChecked, lastChecked) ||
                other.lastChecked == lastChecked) &&
            const DeepCollectionEquality()
                .equals(other._entitlements, _entitlements) &&
            const DeepCollectionEquality()
                .equals(other._subscriptionMetadata, _subscriptionMetadata));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      hasPlus,
      isLoading,
      isRestoring,
      isShowingPaywall,
      error,
      lastChecked,
      const DeepCollectionEquality().hash(_entitlements),
      const DeepCollectionEquality().hash(_subscriptionMetadata));

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscriptionStateImplCopyWith<_$SubscriptionStateImpl> get copyWith =>
      __$$SubscriptionStateImplCopyWithImpl<_$SubscriptionStateImpl>(
          this, _$identity);
}

abstract class _SubscriptionState extends SubscriptionState {
  const factory _SubscriptionState(
          {final bool hasPlus,
          final bool isLoading,
          final bool isRestoring,
          final bool isShowingPaywall,
          final String? error,
          final DateTime? lastChecked,
          final Map<String, bool>? entitlements,
          final Map<String, dynamic>? subscriptionMetadata}) =
      _$SubscriptionStateImpl;
  const _SubscriptionState._() : super._();

  @override
  bool get hasPlus;
  @override
  bool get isLoading;
  @override
  bool get isRestoring;
  @override
  bool get isShowingPaywall;
  @override
  String? get error;
  @override
  DateTime? get lastChecked;
  @override
  Map<String, bool>? get entitlements;
  @override
  Map<String, dynamic>? get subscriptionMetadata;

  /// Create a copy of SubscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscriptionStateImplCopyWith<_$SubscriptionStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PaywallContext {
  String get source => throw _privateConstructorUsedError;
  String? get redirectPath => throw _privateConstructorUsedError;
  Map<String, dynamic>? get parameters => throw _privateConstructorUsedError;
  DateTime? get timestamp => throw _privateConstructorUsedError;

  /// Create a copy of PaywallContext
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PaywallContextCopyWith<PaywallContext> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaywallContextCopyWith<$Res> {
  factory $PaywallContextCopyWith(
          PaywallContext value, $Res Function(PaywallContext) then) =
      _$PaywallContextCopyWithImpl<$Res, PaywallContext>;
  @useResult
  $Res call(
      {String source,
      String? redirectPath,
      Map<String, dynamic>? parameters,
      DateTime? timestamp});
}

/// @nodoc
class _$PaywallContextCopyWithImpl<$Res, $Val extends PaywallContext>
    implements $PaywallContextCopyWith<$Res> {
  _$PaywallContextCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PaywallContext
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? source = null,
    Object? redirectPath = freezed,
    Object? parameters = freezed,
    Object? timestamp = freezed,
  }) {
    return _then(_value.copyWith(
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
      redirectPath: freezed == redirectPath
          ? _value.redirectPath
          : redirectPath // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      timestamp: freezed == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PaywallContextImplCopyWith<$Res>
    implements $PaywallContextCopyWith<$Res> {
  factory _$$PaywallContextImplCopyWith(_$PaywallContextImpl value,
          $Res Function(_$PaywallContextImpl) then) =
      __$$PaywallContextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String source,
      String? redirectPath,
      Map<String, dynamic>? parameters,
      DateTime? timestamp});
}

/// @nodoc
class __$$PaywallContextImplCopyWithImpl<$Res>
    extends _$PaywallContextCopyWithImpl<$Res, _$PaywallContextImpl>
    implements _$$PaywallContextImplCopyWith<$Res> {
  __$$PaywallContextImplCopyWithImpl(
      _$PaywallContextImpl _value, $Res Function(_$PaywallContextImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaywallContext
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? source = null,
    Object? redirectPath = freezed,
    Object? parameters = freezed,
    Object? timestamp = freezed,
  }) {
    return _then(_$PaywallContextImpl(
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
      redirectPath: freezed == redirectPath
          ? _value.redirectPath
          : redirectPath // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      timestamp: freezed == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

class _$PaywallContextImpl extends _PaywallContext {
  const _$PaywallContextImpl(
      {required this.source,
      this.redirectPath,
      final Map<String, dynamic>? parameters,
      this.timestamp})
      : _parameters = parameters,
        super._();

  @override
  final String source;
  @override
  final String? redirectPath;
  final Map<String, dynamic>? _parameters;
  @override
  Map<String, dynamic>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableMapView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final DateTime? timestamp;

  @override
  String toString() {
    return 'PaywallContext(source: $source, redirectPath: $redirectPath, parameters: $parameters, timestamp: $timestamp)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaywallContextImpl &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.redirectPath, redirectPath) ||
                other.redirectPath == redirectPath) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp));
  }

  @override
  int get hashCode => Object.hash(runtimeType, source, redirectPath,
      const DeepCollectionEquality().hash(_parameters), timestamp);

  /// Create a copy of PaywallContext
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PaywallContextImplCopyWith<_$PaywallContextImpl> get copyWith =>
      __$$PaywallContextImplCopyWithImpl<_$PaywallContextImpl>(
          this, _$identity);
}

abstract class _PaywallContext extends PaywallContext {
  const factory _PaywallContext(
      {required final String source,
      final String? redirectPath,
      final Map<String, dynamic>? parameters,
      final DateTime? timestamp}) = _$PaywallContextImpl;
  const _PaywallContext._() : super._();

  @override
  String get source;
  @override
  String? get redirectPath;
  @override
  Map<String, dynamic>? get parameters;
  @override
  DateTime? get timestamp;

  /// Create a copy of PaywallContext
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PaywallContextImplCopyWith<_$PaywallContextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
